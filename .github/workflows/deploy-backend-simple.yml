name: Deploy Go Backend to GCP VM (Simple)

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/**'
  workflow_dispatch:

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  INSTANCE_NAME: crowdfund-backend-vm
  ZONE: us-central1-a
  # Development database configuration - DO NOT use for production!
  POSTGRES_USER: postgres
  POSTGRES_HOST: localhost
  POSTGRES_PORT: 5432
  POSTGRES_DB: crowdfund
  # Note: Sensitive values like POSTGRES_PASSWORD and JWT_SECRET should still use secrets

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    # Skip deployment steps on PRs for security
    env:
      DEPLOY_FROM_PR: ${{ github.event_name != 'pull_request' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
        
    - name: Build Go application
      run: |
        cd backend
        go build -o crowdfund-backend
        
    - name: Set up Cloud SDK
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      uses: 'google-github-actions/setup-gcloud@v1'
      with:
        project_id: ${{ secrets.GCP_PROJECT_ID }}
        
    - name: Authenticate to Google Cloud
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      uses: 'google-github-actions/auth@v1'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'
        
    - name: Create .env file
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      run: |
        cd backend
        cat > .env << EOF
        POSTGRES_USER=${{ env.POSTGRES_USER }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        POSTGRES_HOST=${{ env.POSTGRES_HOST }}
        POSTGRES_PORT=${{ env.POSTGRES_PORT }}
        POSTGRES_DB=${{ env.POSTGRES_DB }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        EOF
        
    - name: Check if VM exists and create if needed
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      run: |
        # Check if VM exists
        if ! gcloud compute instances describe ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} &> /dev/null; then
          echo "VM does not exist. Creating..."
          gcloud compute instances create ${{ env.INSTANCE_NAME }} \
            --zone=${{ env.ZONE }} \
            --machine-type=e2-medium \
            --image-family=debian-12 \
            --image-project=debian-cloud \
            --boot-disk-size=20GB \
            --tags=http-server,https-server
            
          # Allow HTTP/HTTPS traffic
          gcloud compute firewall-rules create allow-http \
            --allow tcp:80 \
            --target-tags=http-server \
            --description="Allow HTTP traffic" || true
          
          gcloud compute firewall-rules create allow-https \
            --allow tcp:443 \
            --target-tags=https-server \
            --description="Allow HTTPS traffic" || true
          
          # Allow custom port for Go backend
          gcloud compute firewall-rules create allow-go-backend \
            --allow tcp:8080 \
            --target-tags=http-server \
            --description="Allow Go backend traffic" || true
            
          # Install PostgreSQL on the VM
          gcloud compute ssh ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --command="
            sudo apt-get update
            sudo apt-get install -y postgresql postgresql-contrib
            sudo systemctl start postgresql
            sudo systemctl enable postgresql
            
            # Create database and user if they don't exist
            sudo -u postgres psql -c \"CREATE DATABASE ${{ env.POSTGRES_DB }}\" || true
            sudo -u postgres psql -c \"CREATE USER ${{ env.POSTGRES_USER }} WITH PASSWORD '${{ secrets.POSTGRES_PASSWORD }}'\" || true
            sudo -u postgres psql -c \"ALTER ROLE ${{ env.POSTGRES_USER }} WITH SUPERUSER\" || true
          "
        else
          echo "VM already exists."
        fi
        
    - name: Deploy to VM instance
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      run: |
        # Create a deployment package
        cd backend
        tar -czf ../deploy.tar.gz crowdfund-backend .env
        
        # Copy files to the VM
        gcloud compute scp ../deploy.tar.gz ${{ env.INSTANCE_NAME }}:~ --zone=${{ env.ZONE }}
        
        # SSH into the VM and deploy
        gcloud compute ssh ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --command="
          # Extract the deployment package
          tar -xzf deploy.tar.gz -C /tmp
          
          # Stop the existing service if it's running
          sudo systemctl stop crowdfund-backend.service || true
          
          # Move the files to the deployment directory
          sudo mkdir -p /opt/crowdfund
          sudo cp /tmp/crowdfund-backend /opt/crowdfund/
          sudo cp /tmp/.env /opt/crowdfund/
          sudo chmod +x /opt/crowdfund/crowdfund-backend
          
          # Create or update the systemd service
          cat > /tmp/crowdfund-backend.service << 'EOF'
          [Unit]
          Description=Crowdfund Backend Service
          After=network.target
          
          [Service]
          Type=simple
          User=root
          WorkingDirectory=/opt/crowdfund
          EnvironmentFile=/opt/crowdfund/.env
          ExecStart=/opt/crowdfund/crowdfund-backend
          Restart=always
          RestartSec=5
          
          [Install]
          WantedBy=multi-user.target
          EOF
          
          sudo mv /tmp/crowdfund-backend.service /etc/systemd/system/
          sudo systemctl daemon-reload
          sudo systemctl enable crowdfund-backend.service
          sudo systemctl start crowdfund-backend.service
          
          # Clean up
          rm deploy.tar.gz
        "
        
    - name: Show deployment info
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      run: |
        echo "Backend deployed to VM: ${{ env.INSTANCE_NAME }}"
        EXTERNAL_IP=$(gcloud compute instances describe ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
        echo "External IP: $EXTERNAL_IP"
