name: Deploy Go Backend to GCP VM (Simple)

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/**'
  workflow_dispatch:

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  INSTANCE_NAME: crowdfund-backend-vm
  ZONE: us-central1-a
  # Development database configuration - DO NOT use for production!
  POSTGRES_USER: postgres
  POSTGRES_HOST: localhost
  POSTGRES_PORT: 5432
  POSTGRES_DB: crowdfund
  # Note: Sensitive values like POSTGRES_PASSWORD and JWT_SECRET should still use secrets

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    # Skip deployment steps on PRs for security
    env:
      DEPLOY_FROM_PR: ${{ github.event_name != 'pull_request' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
        
    - name: Build Go application
      run: |
        cd backend
        go build -o crowdfund-backend

    - name: Authenticate to Google Cloud
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      uses: 'google-github-actions/auth@v1'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'
      #   service_account: 'crowdfund-deployer@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com'
      #  create_credentials_file: true
        export_environment_variables: true    

    - name: Set up Cloud SDK
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      uses: 'google-github-actions/setup-gcloud@v1'
      with:
        project_id: ${{ secrets.GCP_PROJECT_ID }}    
 
        

        
    - name: Create .env file
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      run: |
        cd backend
        cat > .env << EOF
        POSTGRES_USER=${{ env.POSTGRES_USER }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        POSTGRES_HOST=${{ env.POSTGRES_HOST }}
        POSTGRES_PORT=${{ env.POSTGRES_PORT }}
        POSTGRES_DB=${{ env.POSTGRES_DB }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        EOF
        
    - name: Debug environment
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      run: |
        echo "Project ID: ${{ env.PROJECT_ID }}"
        echo "Instance Name: ${{ env.INSTANCE_NAME }}"
        echo "Zone: ${{ env.ZONE }}"
        gcloud config list
        gcloud auth list
        
    - name: Create VM instance
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      run: |
        echo "Creating VM instance..."
        # Force create the VM (ignore if it already exists)
        gcloud compute instances create ${{ env.INSTANCE_NAME }} \
          --zone=${{ env.ZONE }} \
          --machine-type=e2-medium \
          --image-family=debian-12 \
          --image-project=debian-cloud \
          --boot-disk-size=20GB \
          --tags=http-server,https-server || echo "VM may already exist, continuing..."
        
        # Wait for VM to be ready
        echo "Waiting for VM to be ready..."
        sleep 60
        
        # Verify VM exists
        echo "Verifying VM exists..."
        gcloud compute instances describe ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }}
        
        # Set up firewall rules
        echo "Setting up firewall rules..."
        gcloud compute firewall-rules create allow-postgres --allow tcp:5432 --target-tags=http-server || echo "Firewall rule already exists"
        gcloud compute firewall-rules create allow-go-app --allow tcp:8080 --target-tags=http-server || echo "Firewall rule already exists"
    
    - name: Install PostgreSQL
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      run: |
        echo "Installing PostgreSQL on the VM..."
        gcloud compute ssh ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --command="sudo apt-get update && sudo apt-get install -y postgresql postgresql-contrib"
        
        # Configure PostgreSQL
        echo "Configuring PostgreSQL..."
        gcloud compute ssh ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --command="sudo -u postgres psql -c \"ALTER USER postgres WITH PASSWORD '${{ secrets.POSTGRES_PASSWORD }}';\""
        gcloud compute ssh ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --command="sudo -u postgres psql -c \"CREATE DATABASE crowdfund;\""
        
        # Configure PostgreSQL to accept connections from anywhere
        echo "Configuring PostgreSQL to accept connections..."
        gcloud compute ssh ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --command="sudo sed -i \"s/#listen_addresses = 'localhost'/listen_addresses = '*'/\" /etc/postgresql/*/main/postgresql.conf"
        gcloud compute ssh ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --command="sudo bash -c 'echo \"host all all 0.0.0.0/0 md5\" >> /etc/postgresql/*/main/pg_hba.conf'"
        gcloud compute ssh ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --command="sudo systemctl restart postgresql"
        
    - name: Deploy to VM instance
      if: ${{ env.DEPLOY_FROM_PR == 'true' }}
      run: |
        # Create a deployment package
        cd backend
        tar -czf ../deploy.tar.gz crowdfund-backend .env
        
        # Verify VM exists before attempting to deploy
        echo "Verifying VM exists before deployment..."
        gcloud compute instances describe ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }}
        
        # Copy files to VM
        echo "Copying files to VM..."
        gcloud compute scp ../deploy.tar.gz ${{ env.INSTANCE_NAME }}:~ --zone=${{ env.ZONE }}
        
        # Deploy on VM
        echo "Deploying application on VM..."
        gcloud compute ssh ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --command="
          # Extract files
          tar -xzf deploy.tar.gz -C ~/ && 
          
          # Stop existing application if running
          pkill -f crowdfund-backend || true && 
          
          # Start the application in the background
          nohup ./crowdfund-backend > app.log 2>&1 &
          
          # Show confirmation
          echo 'Deployment completed successfully!'
        "
        
        # Get the external IP of the VM
        EXTERNAL_IP=$(gcloud compute instances describe ${{ env.INSTANCE_NAME }} --zone=${{ env.ZONE }} --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
        echo "Application deployed to: http://$EXTERNAL_IP:8080"
